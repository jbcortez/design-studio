import { ActionCreatorWithPayload } from "@reduxjs/toolkit";
import React from "react";
import { CanvasList, ElementIds, Pos, Style } from "../types";
import { removeElement } from "../redux/elementSlice";
import { setStatus } from "../redux/canvasSlice";
import { setCurrentComponent } from "../redux/currentComponentSlice";

// Source: https://stackoverflow.com/questions/54738221/typescript-array-find-possibly-undefind
// Ensures that TypeError will be thrown if argument isn't found.
// Used with Array.find
export const ensure = <T>(
  argument: T | undefined | null,
  message: string = "Value not found."
): T => {
  if (argument === undefined || argument === null) {
    console.log("type error!", argument);
    throw new TypeError(message);
  }

  return argument;
};

/*
setPos: Pos is passed to <Draggable /> to set the position (x,y) of the element. It is converted to translate(x, y).
scale: From the useZoom hook. Number between 0 and 1. 
*/

export const handleResize = (
  e: React.MouseEvent<HTMLDivElement>,
  myRef: React.RefObject<HTMLDivElement | HTMLButtonElement>,
  dispatch: Function,
  resize: ActionCreatorWithPayload<{
    width: number;
    height: number;
    top: number;
    left: number;
    editingMode: string;
    undo: boolean;
    id: string;
  }>,
  id: string,
  editingMode: string,
  setPos: (
    value: (prevPos: { x: number; y: number }) => { x: number; y: number }
  ) => void,
  scale: number,
  pos: any,
  setBounds: any,
  rect: any,
  isTypography = false
) => {
  e.stopPropagation();

  const ratio = 1 / scale;

  let targetPos: Pos = { x: 0, y: 0 };

  let prevX = e.clientX;
  let prevY = e.clientY;
  const regx = /(-?[0-9]+\.?[0-9]*)/g;
  let originalPos = JSON.parse(JSON.stringify(pos));

  const mouseMove = (event: MouseEvent) => {
    if (myRef.current) {
      const matches: RegExpMatchArray | null =
        myRef.current.style.transform.match(regx);

      // targetPos is the current pos (x,y) pull from the translate(x,y) style generated by getStyles() and used for positioning a <Draggable /> component.
      // We dispatch it onMouseUp to set the final position of the element in redux.
      if (matches) {
        targetPos = {
          x: parseFloat(matches[0]),
          y: parseFloat(matches[1]),
        };
      }

      const width = parseFloat(myRef.current.style.width);
      const height = parseFloat(myRef.current.style.height);

      const target = e.target as Element;

      if (target.classList.contains("se")) {
        myRef.current.style.width =
          width + (event.pageX - prevX) * ratio + "px";
        myRef.current.style.height =
          height + (event.pageY - prevY) * ratio + "px";
      } else if (target.classList.contains("side-handle")) {
        myRef.current.style.width =
          width + (event.pageX - prevX) * ratio + "px";
      } else if (target.classList.contains("ne")) {
        originalPos = {
          ...originalPos,
          y: originalPos.y + (event.clientY - prevY) * ratio,
        };
        setPos(() => originalPos);
        myRef.current.style.top =
          myRef.current.style.top + (event.clientY - prevY) * ratio;

        myRef.current.style.height =
          height + (prevY - event.clientY) * ratio + "px";
        myRef.current.style.width =
          width - (prevX - event.clientX) * ratio + "px";
      } else if (target.classList.contains("sw")) {
        myRef.current.style.width =
          width + (prevX - event.clientX) * ratio + "px";
        myRef.current.style.height =
          height - (prevY - event.clientY) * ratio + "px";
        originalPos = {
          ...originalPos,
          x: originalPos.x - (prevX - event.clientX) * ratio,
        };
        setPos(() => originalPos);
      } else if (target.classList.contains("nw")) {
        originalPos = {
          x: originalPos.x - (prevX - event.clientX) * ratio,
          y: originalPos.y - (prevY - event.clientY) * ratio,
        };
        setPos(() => originalPos);

        myRef.current.style.height =
          height + (prevY - event.clientY) * ratio + "px";
        myRef.current.style.width =
          width + (prevX - event.clientX) * ratio + "px";
      }
    }

    prevY = event.pageY;
    prevX = event.pageX;
  };

  const mouseUp = () => {
    window.removeEventListener("mousemove", mouseMove);
    window.removeEventListener("mouseup", mouseUp);

    if (myRef.current) {
      const width = parseFloat(myRef.current.style.width);
      const height = parseFloat(myRef.current.style.height);

      if (setBounds && myRef.current) {
        const elementRect = myRef.current.getBoundingClientRect();

        setBounds({
          top: 0 - elementRect.height + 20,
          bottom: rect.height - 20,
          left: 0 - elementRect.width + 20,
          right: rect.width - 20,
        });
      }

      if ((!isNaN(width) && !isNaN(height)) || isTypography) {
        dispatch(
          resize({
            id,
            editingMode,
            top: targetPos.y,
            left: targetPos.x,
            width,
            height,
            undo: true,
          })
        );
      } else {
        console.error(
          `TypeError: width(${width}) and height(${height}) must be numbers.`
        );
      }
    }
  };

  window.addEventListener("mousemove", mouseMove);
  window.addEventListener("mouseup", mouseUp);
};

export const setAlert = (msg, typ, dispatch) => {
  if (msg && typ && dispatch) {
    dispatch(setStatus({ message: msg, type: typ }));

    setTimeout(
      () => dispatch(setStatus({ message: undefined, type: undefined })),
      5000
    );
  }
};

export const getShapeStyles = (
  styles: Style,
  site,
  transform?: React.CSSProperties["transform"]
) => {
  return {
    top: site ? styles?.top?.value : undefined,
    left: site ? styles?.left?.value : undefined,
    position: "absolute",
    height: styles.height?.value + "px",
    width: styles.width?.value + "px",
    transform: `${transform} ${
      styles?.transform?.value ? styles.transform.value : ""
    }`,
    borderTopLeftRadius: styles.borderTopLeftRadius?.value + "%",
    borderTopRightRadius: styles.borderTopRightRadius?.value + "%",
    borderBottomLeftRadius: styles.borderBottomLeftRadius?.value + "%",
    borderBottomRightRadius: styles.borderBottomRightRadius?.value + "%",
    zIndex: styles.zIndex?.value,
  };
};

// In order to use hover styles, we cant use inline styles. Instead, we use this function on buttons to set the position with transform, and the height and width to enable the use of ref.current.style.height/width when resizing.
export const getButtonStyles = (
  styles: Style,
  transform: React.CSSProperties["transform"]
) => {
  return {
    top: undefined,
    left: undefined,
    height: styles.height?.value + "px",
    width: styles.width?.value + "px",
    transform: `${transform} ${
      styles?.transform?.value ? styles.transform.value : ""
    }`,
  };
};

export const getImageStyles = (
  styles: Style,
  transform: React.CSSProperties["transform"]
) => {
  return {
    position: styles.position?.value ? styles.position.value : "absolute",
    top: undefined,
    left: undefined,
    borderColor: styles.borderColor?.value,
    borderStyle: styles.borderStyle?.value,
    borderWidth:
      typeof styles.borderWidth?.value !== "undefined"
        ? styles.borderWidth.value / 10 + "rem"
        : "3",

    height:
      typeof styles.height?.value === "string"
        ? styles.height.value
        : typeof styles.height?.value !== "undefined"
        ? styles.height.value + "px"
        : "",
    width:
      typeof styles.width?.value === "string"
        ? styles.width.value
        : typeof styles.width?.value !== "undefined"
        ? styles.width.value + "px"
        : "",
    objectFit: styles?.objectFit?.value,
    zIndex: styles?.zIndex?.value,
    transform: `${transform} ${
      styles?.transform?.value ? styles.transform.value : ""
    }`,
    boxShadow: styles?.boxShadow?.value,
  };
};

export const getStyles = (
  styles: Style,
  transform: React.CSSProperties["transform"],
  isTypography = false
) => {
  return {
    position: styles.position?.value ? styles.position.value : "absolute",
    top: undefined,
    left: undefined,
    fontSize: styles.fontSize?.value && styles.fontSize.value / 10 + "rem",
    color: styles.color?.value,
    background: styles.background?.value,
    fontStyle: styles.fontStyle?.value,
    textDecoration: styles.textDecoration?.value,
    textAlign: styles.textAlign?.value,
    fontFamily: styles.fontFamily?.value,
    lineHeight: styles.lineHeight?.value,
    fontWeight: styles.fontWeight?.value,
    borderColor: styles.borderColor?.value,
    borderStyle: styles.borderStyle?.value,
    borderWidth:
      typeof styles.borderWidth?.value !== "undefined"
        ? styles.borderWidth.value / 10 + "rem"
        : "3",

    borderTopLeftRadius:
      typeof styles.borderTopLeftRadius?.value !== "undefined"
        ? styles.borderTopLeftRadius + "%"
        : undefined,
    borderBottomLeftRadius:
      typeof styles.borderBottomLeftRadius?.value !== "undefined"
        ? styles.borderBottomLeftRadius + "%"
        : undefined,
    borderTopRightRadius:
      typeof styles.borderTopRightRadius?.value !== "undefined"
        ? styles.borderTopRightRadius + "%"
        : undefined,
    borderBottomRightRadius:
      typeof styles.borderBottomRightRadius?.value !== "undefined"
        ? styles.borderBottomRightRadius + "%"
        : undefined,
    paddingLeft:
      styles?.paddingLeft?.value && styles.paddingLeft.value / 10 + "rem",
    paddingRight:
      styles?.paddingRight?.value && styles.paddingRight.value / 10 + "rem",
    paddingTop:
      styles?.paddingTop?.value && styles.paddingTop.value / 10 + "rem",
    paddingBottom:
      styles?.paddingBottom?.value && styles.paddingBottom.value / 10 + "rem",

    height: isTypography
      ? "auto"
      : typeof styles.height?.value === "string"
      ? styles.height.value
      : typeof styles.height?.value !== "undefined"
      ? styles.height.value + "px"
      : "",
    width:
      typeof styles.width?.value === "string"
        ? styles.width.value
        : typeof styles.width?.value !== "undefined"
        ? styles.width.value + "px"
        : "",
    objectFit: styles?.objectFit?.value,
    letterSpacing: styles?.letterSpacing?.value,
    zIndex: styles?.zIndex?.value,
    textTransform: styles?.textTransform?.value,
    transform: `${transform} ${
      styles?.transform?.value ? styles.transform.value : ""
    }`,
    boxShadow: styles?.boxShadow?.value,
  };
};

export const handleBackspace = (
  e: React.KeyboardEvent,
  dispatch: Function,
  selected: ElementIds
) => {
  if (e.key === "Backspace") {
    dispatch(removeElement({ selected }));
    dispatch(setCurrentComponent({ id: null, type: null }));
  }
};

export const mergeRefs = (refs, element) => {
  refs.forEach((ref) => {
    if (typeof ref === "function") ref(element);
    else if (ref != null) ref.current = element;
  });
};

export const queryActiveFontLinks = () => {
  const links = document.querySelectorAll('[data-type="active-font"]');

  const linkFamilies: string[] = [];

  links.forEach((link) => {
    const castLink = link as HTMLElement;
    if (castLink.dataset.family) linkFamilies.push(castLink.dataset.family);
  });

  return linkFamilies;
};

export const addToContentList = (id: string) => {
  let canvasList: { id: string }[] | null | string = null;
  const canvasListItem = { id: id };
  canvasList = localStorage.getItem("canvasList");

  if (canvasList) {
    canvasList = JSON.parse(canvasList) as { id: string }[];

    if (!canvasList.some((item) => item.id === canvasListItem.id)) {
      canvasList.push(canvasListItem);
      localStorage.setItem("canvasList", JSON.stringify(canvasList));
    }
  } else {
    canvasList = [] as CanvasList;
    canvasList.push(canvasListItem);
    localStorage.setItem("canvasList", JSON.stringify(canvasList));
  }
};

export const convertArrayTo3d = (list: any[]): any[][] => {
  let tmpList: any[] = [];
  const newList: any[] = [];
  for (let i = 0; i < list.length; i++) {
    if (tmpList.length < 3) {
      tmpList.push(list[i]);
    } else {
      newList.push(tmpList);
      tmpList = [list[i]];
    }
    if (i === list.length - 1) {
      newList.push(tmpList);
    }
  }

  return newList;
};
